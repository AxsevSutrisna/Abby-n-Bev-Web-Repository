import {
  RateLimiterBridge,
  debug_default
} from "../../chunk-RWNA5JOS.js";
import "../../chunk-MLKGABMK.js";

// src/stores/redis.ts
import string from "@adonisjs/core/helpers/string";
import { RateLimiterRedis } from "rate-limiter-flexible";
import { RedisClusterConnection } from "@adonisjs/redis";
var LimiterRedisStore = class extends RateLimiterBridge {
  #client;
  get name() {
    return "redis";
  }
  constructor(client, config) {
    debug_default("creating redis limiter store %O", config);
    super(
      new RateLimiterRedis({
        rejectIfRedisNotReady: config.rejectIfRedisNotReady,
        storeClient: client.ioConnection,
        keyPrefix: config.keyPrefix,
        execEvenly: config.execEvenly,
        points: config.requests,
        duration: string.seconds.parse(config.duration),
        inMemoryBlockOnConsumed: config.inMemoryBlockOnConsumed,
        blockDuration: config.blockDuration ? string.seconds.parse(config.blockDuration) : void 0,
        inMemoryBlockDuration: config.inMemoryBlockDuration ? string.seconds.parse(config.inMemoryBlockDuration) : void 0
      })
    );
    this.#client = client;
  }
  /**
   * Flushes the redis database to clear existing
   * rate limits.
   *
   * Make sure to use a separate db for store rate limits
   * as this method flushes the entire database
   */
  async clear() {
    this.deleteInMemoryBlockedKeys();
    if (this.#client instanceof RedisClusterConnection) {
      debug_default("flushing redis cluster");
      for (let node of this.#client.nodes("master")) {
        await node.flushdb();
      }
    } else {
      debug_default("flushing redis database");
      await this.#client.flushdb();
    }
  }
};
export {
  LimiterRedisStore as default
};
