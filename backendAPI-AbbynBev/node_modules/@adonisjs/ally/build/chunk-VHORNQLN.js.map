{"version":3,"sources":["../src/abstract_drivers/oauth1.ts"],"sourcesContent":["/*\n * @adonisjs/ally\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { Exception } from '@poppinss/utils'\nimport type { HttpContext } from '@adonisjs/core/http'\nimport { Oauth1Client } from '@poppinss/oauth-client/oauth1'\n\nimport {\n  AllyUserContract,\n  Oauth1AccessToken,\n  Oauth1DriverConfig,\n  ApiRequestContract,\n  AllyDriverContract,\n  RedirectRequestContract,\n} from '../types.js'\n\nimport * as errors from '../errors.js'\nimport { RedirectRequest } from '../redirect_request.js'\n\n/**\n * Abstract implementation for an Oauth1 driver\n */\nexport abstract class Oauth1Driver<Token extends Oauth1AccessToken, Scopes extends string>\n  extends Oauth1Client<Token>\n  implements AllyDriverContract<Token, Scopes>\n{\n  /**\n   * The cookie name for storing the \"oauth_token\". Must be unique for your\n   * driver. One option is to prefix the driver name. For example:\n   * `twitter_oauth_token`\n   */\n  protected abstract oauthTokenCookieName: string\n\n  /**\n   * Name of the \"oauth_token\" param. This is the query string value post\n   * authorization redirect\n   */\n  protected abstract oauthTokenParamName: string\n\n  /**\n   * Name of the \"oauth_verifier\" param. This is the query string value post\n   * authorization redirect\n   */\n  protected abstract oauthTokenVerifierName: string\n\n  /**\n   * The parameter name from which to fetch the error message or error code\n   * post redirect.\n   *\n   * You must check the auth provider docs to find it\n   */\n  protected abstract errorParamName: string\n\n  /**\n   * Request token URL for the auth provider. The initial set of tokens\n   * are generated from this url\n   */\n  protected abstract requestTokenUrl: string\n\n  /**\n   * Authorization URL for the auth provider. The user will be redirected\n   * to this URL\n   */\n  protected abstract authorizeUrl: string\n\n  /**\n   * The URL to hit to get an access token\n   */\n  protected abstract accessTokenUrl: string\n\n  /**\n   * The query param name for defining the Authorization scopes.\n   * Mostly it is `scope`. Leave to empty string when scopes\n   * are not applicable\n   */\n  protected abstract scopeParamName: string\n\n  /**\n   * The identifier for joining multiple scopes. Mostly it is a space.\n   */\n  protected abstract scopesSeparator: string\n\n  /**\n   * Returns details for the authorized user\n   */\n  abstract user(callback?: (request: ApiRequestContract) => void): Promise<AllyUserContract<Token>>\n\n  /**\n   * Finds the user by access token\n   */\n  abstract userFromTokenAndSecret(\n    token: string,\n    secret: string,\n    callback?: (request: ApiRequestContract) => void\n  ): Promise<AllyUserContract<{ token: string; secret: string }>>\n\n  /**\n   * Find if the current error code is for access denied\n   */\n  abstract accessDenied(): boolean\n\n  /**\n   * Oauth client version\n   */\n  version = 'oauth1' as const\n\n  /**\n   * The value of \"oauth_token\" and \"oauth_secret\" from the cookies\n   */\n  protected oauthTokenCookieValue?: string\n  protected oauthSecretCookieValue?: string\n\n  /**\n   * The cookie name for storing the secret\n   */\n  protected get oauthSecretCookieName() {\n    return `${this.oauthTokenCookieName}_secret`\n  }\n\n  constructor(\n    protected ctx: HttpContext,\n    public config: Oauth1DriverConfig\n  ) {\n    super(config)\n  }\n\n  /**\n   * The Oauth1Client will use the instance returned from this method to\n   * build the redirect url\n   */\n  protected urlBuilder(url: string) {\n    return new RedirectRequest(url, this.scopeParamName, this.scopesSeparator)\n  }\n\n  /**\n   * Loads the value of state from the cookie and removes it right\n   * away. We read the cookie value and clear it during the\n   * current request lifecycle.\n   *\n   * :::::\n   * NOTE\n   * :::::\n   *\n   * This child class must call this method inside the constructor.\n   */\n  protected loadState() {\n    /**\n     * Read and cache in-memory\n     */\n    this.oauthTokenCookieValue = this.ctx.request.encryptedCookie(this.oauthTokenCookieName)\n    this.oauthSecretCookieValue = this.ctx.request.encryptedCookie(this.oauthSecretCookieName)\n\n    /**\n     * Clear cookies\n     */\n    this.ctx.response.clearCookie(this.oauthTokenCookieName)\n    this.ctx.response.clearCookie(this.oauthSecretCookieName)\n  }\n\n  /**\n   * Persists the token (aka state) inside the cookie\n   */\n  #persistToken(token: string): void {\n    this.ctx.response.encryptedCookie(this.oauthTokenCookieName, token, {\n      sameSite: false,\n      httpOnly: true,\n    })\n  }\n\n  /**\n   * Persists the secret inside the cookie\n   */\n  #persistSecret(secret: string): void {\n    this.ctx.response.encryptedCookie(this.oauthSecretCookieName, secret, {\n      sameSite: false,\n      httpOnly: true,\n    })\n  }\n\n  /**\n   * Perform stateless authentication. Only applicable for Oauth1 client\n   */\n  stateless(): never {\n    throw new Exception('OAuth1 does not support stateless authorization')\n  }\n\n  /**\n   * Returns the redirect URL for the request.\n   */\n  async redirectUrl(\n    callback?: (request: RedirectRequestContract<Scopes>) => void\n  ): Promise<string> {\n    return this.getRedirectUrl(callback as any)\n  }\n\n  /**\n   * Redirect user for authorization.\n   */\n  async redirect(callback?: (request: RedirectRequestContract<Scopes>) => void): Promise<void> {\n    const { token, secret } = await this.getRequestToken()\n\n    /**\n     * Storing token and secret inside cookies. We need them\n     * later\n     */\n    this.#persistToken(token)\n    this.#persistSecret(secret)\n\n    const url = await this.redirectUrl((request) => {\n      request.param(this.oauthTokenParamName, token)\n\n      if (typeof callback === 'function') {\n        callback(request)\n      }\n    })\n\n    this.ctx.response.redirect(url)\n  }\n\n  /**\n   * Find if there is a state mismatch\n   */\n  stateMisMatch(): boolean {\n    return this.oauthTokenCookieValue !== this.ctx.request.input(this.oauthTokenParamName)\n  }\n\n  /**\n   * Find if there is an error post redirect\n   */\n  hasError(): boolean {\n    return !!this.getError()\n  }\n\n  /**\n   * Get the post redirect error\n   */\n  getError(): string | null {\n    const error = this.ctx.request.input(this.errorParamName)\n    if (error) {\n      return error\n    }\n\n    if (!this.hasCode()) {\n      return 'unknown_error'\n    }\n\n    return null\n  }\n\n  /**\n   * Returns the \"oauth_verifier\" token\n   */\n  getCode(): string | null {\n    return this.ctx.request.input(this.oauthTokenVerifierName, null)\n  }\n\n  /**\n   * Find it the code exists\n   */\n  hasCode(): boolean {\n    return !!this.getCode()\n  }\n\n  /**\n   * Get access token\n   */\n  async accessToken(callback?: (request: ApiRequestContract) => void): Promise<Token> {\n    /**\n     * We expect the user to handle errors before calling this method\n     */\n    if (this.hasError()) {\n      throw new errors.E_OAUTH_MISSING_CODE([this.oauthTokenVerifierName])\n    }\n\n    /**\n     * We expect the user to properly handle the state mis-match use case before\n     * calling this method\n     */\n    if (this.stateMisMatch()) {\n      throw new errors.E_OAUTH_STATE_MISMATCH()\n    }\n\n    /**\n     * Get access token by providing the authorization code\n     */\n    return this.getAccessToken(\n      { token: this.oauthTokenCookieValue!, secret: this.oauthSecretCookieValue! },\n      (request) => {\n        request.oauth1Param(this.oauthTokenVerifierName, this.getCode())\n\n        if (typeof callback === 'function') {\n          callback(request)\n        }\n      }\n    )\n  }\n\n  /**\n   * Not applicable with Oauth1\n   */\n  async userFromToken(): Promise<never> {\n    throw new Exception(\n      '\"userFromToken\" is not available with Oauth1. Use \"userFromTokenAndSecret\" instead'\n    )\n  }\n}\n"],"mappings":"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","names":[]}