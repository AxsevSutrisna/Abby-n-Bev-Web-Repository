import {
  E_OAUTH_MISSING_CODE,
  E_OAUTH_STATE_MISMATCH,
  RedirectRequest
} from "./chunk-N72DEJC2.js";

// src/abstract_drivers/oauth2.ts
import { Exception } from "@poppinss/utils";
import { Oauth2Client } from "@poppinss/oauth-client/oauth2";
var Oauth2Driver = class extends Oauth2Client {
  constructor(ctx, config) {
    super(config);
    this.ctx = ctx;
    this.config = config;
  }
  /**
   * Is the authorization process stateless?
   */
  isStateless = false;
  /**
   * Oauth client version
   */
  version = "oauth2";
  /**
   * The value of state read from the cookies.
   */
  stateCookieValue;
  /**
   * The Oauth2Client will use the instance returned from this method to
   * build the redirect url
   */
  urlBuilder(url) {
    return new RedirectRequest(url, this.scopeParamName, this.scopesSeparator);
  }
  /**
   * Loads the value of state from the cookie and removes it right
   * away. We read the cookie value and clear it during the
   * current request lifecycle.
   *
   * :::::
   * NOTE
   * :::::
   *
   * This child class must call this method inside the constructor.
   */
  loadState() {
    if (this.isStateless) {
      return;
    }
    this.stateCookieValue = this.ctx.request.encryptedCookie(this.stateCookieName);
    this.ctx.response.clearCookie(this.stateCookieName);
  }
  /**
   * Persists the state inside the cookie
   */
  #persistState() {
    if (this.isStateless) {
      return;
    }
    const state = this.getState();
    this.ctx.response.encryptedCookie(this.stateCookieName, state, {
      sameSite: false,
      httpOnly: true
    });
    return state;
  }
  /**
   * Perform stateless authentication. Only applicable for Oauth2 client
   */
  stateless() {
    this.isStateless = true;
    return this;
  }
  /**
   * Returns the redirect URL for the request.
   */
  async redirectUrl(callback) {
    const url = this.getRedirectUrl(callback);
    return url;
  }
  /**
   * Redirect user for authorization.
   */
  async redirect(callback) {
    const url = await this.redirectUrl((request) => {
      const state = this.#persistState();
      state && request.param(this.stateParamName, state);
      if (typeof callback === "function") {
        callback(request);
      }
    });
    this.ctx.response.redirect(url);
  }
  /**
   * Find if there is a state mismatch
   */
  stateMisMatch() {
    if (this.isStateless) {
      return false;
    }
    return this.stateCookieValue !== this.ctx.request.input(this.stateParamName);
  }
  /**
   * Find if there is an error post redirect
   */
  hasError() {
    return !!this.getError();
  }
  /**
   * Get the post redirect error
   */
  getError() {
    const error = this.ctx.request.input(this.errorParamName);
    if (error) {
      return error;
    }
    if (!this.hasCode()) {
      return "unknown_error";
    }
    return null;
  }
  /**
   * Returns the authorization code
   */
  getCode() {
    return this.ctx.request.input(this.codeParamName, null);
  }
  /**
   * Find it the code exists
   */
  hasCode() {
    return !!this.getCode();
  }
  /**
   * Get access token
   */
  async accessToken(callback) {
    if (this.hasError()) {
      throw new E_OAUTH_MISSING_CODE([this.codeParamName]);
    }
    if (this.stateMisMatch()) {
      throw new E_OAUTH_STATE_MISMATCH();
    }
    return this.getAccessToken((request) => {
      request.field(this.codeParamName, this.getCode());
      if (typeof callback === "function") {
        callback(request);
      }
    });
  }
  /**
   * Not applicable with Oauth2
   */
  async userFromTokenAndSecret() {
    throw new Exception(
      '"userFromTokenAndSecret" is not applicable with Oauth2. Use "userFromToken" instead'
    );
  }
};

export {
  Oauth2Driver
};
//# sourceMappingURL=chunk-GWAQFMNS.js.map