{"version":3,"sources":["../src/abstract_drivers/oauth2.ts"],"sourcesContent":["/*\n * @adonisjs/ally\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { Exception } from '@poppinss/utils'\nimport type { HttpContext } from '@adonisjs/core/http'\nimport { Oauth2Client } from '@poppinss/oauth-client/oauth2'\n\nimport {\n  AllyUserContract,\n  Oauth2AccessToken,\n  Oauth2DriverConfig,\n  ApiRequestContract,\n  AllyDriverContract,\n  RedirectRequestContract,\n} from '../types.js'\n\nimport * as errors from '../errors.js'\nimport { RedirectRequest } from '../redirect_request.js'\n\n/**\n * Abstract implementation for an Oauth2 driver\n */\nexport abstract class Oauth2Driver<Token extends Oauth2AccessToken, Scopes extends string>\n  extends Oauth2Client<Token>\n  implements AllyDriverContract<Token, Scopes>\n{\n  /**\n   * Is the authorization process stateless?\n   */\n  protected isStateless: boolean = false\n\n  /**\n   * The cookie name for storing the CSRF token. Must be unique for your\n   * driver. One option is to prefix the driver name. For example:\n   * `gh_oauth_state`\n   */\n  protected abstract stateCookieName: string\n\n  /**\n   * The parameter in which to send the state to the oauth provider. The same\n   * input is used to retrieve the state post redirect as well.\n   *\n   * You must check the auth provider docs to find it\n   */\n  protected abstract stateParamName: string\n\n  /**\n   * The parameter name from which to fetch the error message or error code\n   * post redirect.\n   *\n   * You must check the auth provider docs to find it\n   */\n  protected abstract errorParamName: string\n\n  /**\n   * The parameter name from which to fetch the authorization code. It is usually\n   * named as \"code\".\n   *\n   * You must check the auth provider docs to find it\n   */\n  protected abstract codeParamName: string\n\n  /**\n   * Authorization URL for the auth provider. The user will be redirected\n   * to this URL\n   */\n  protected abstract authorizeUrl: string\n\n  /**\n   * The URL to hit to get an access token\n   */\n  protected abstract accessTokenUrl: string\n\n  /**\n   * The query param name for defining the Authorization scopes.\n   * Mostly it is `scope`\n   */\n  protected abstract scopeParamName: string\n\n  /**\n   * The identifier for joining multiple scopes. Mostly it is a space.\n   */\n  protected abstract scopesSeparator: string\n\n  /**\n   * Returns details for the authorized user\n   */\n  abstract user(callback?: (request: ApiRequestContract) => void): Promise<AllyUserContract<Token>>\n\n  /**\n   * Finds the user by access token\n   */\n  abstract userFromToken(\n    token: string,\n    callback?: (request: ApiRequestContract) => void\n  ): Promise<AllyUserContract<{ token: string; type: 'bearer' }>>\n\n  /**\n   * Find if the current error code is for access denied\n   */\n  abstract accessDenied(): boolean\n\n  /**\n   * Oauth client version\n   */\n  version = 'oauth2' as const\n\n  /**\n   * The value of state read from the cookies.\n   */\n  protected stateCookieValue?: string\n\n  constructor(\n    protected ctx: HttpContext,\n    public config: Oauth2DriverConfig\n  ) {\n    super(config)\n  }\n\n  /**\n   * The Oauth2Client will use the instance returned from this method to\n   * build the redirect url\n   */\n  protected urlBuilder(url: string) {\n    return new RedirectRequest(url, this.scopeParamName, this.scopesSeparator)\n  }\n\n  /**\n   * Loads the value of state from the cookie and removes it right\n   * away. We read the cookie value and clear it during the\n   * current request lifecycle.\n   *\n   * :::::\n   * NOTE\n   * :::::\n   *\n   * This child class must call this method inside the constructor.\n   */\n  protected loadState() {\n    if (this.isStateless) {\n      return\n    }\n\n    this.stateCookieValue = this.ctx.request.encryptedCookie(this.stateCookieName)\n    this.ctx.response.clearCookie(this.stateCookieName)\n  }\n\n  /**\n   * Persists the state inside the cookie\n   */\n  #persistState(): string | undefined {\n    if (this.isStateless) {\n      return\n    }\n\n    const state = this.getState()\n    this.ctx.response.encryptedCookie(this.stateCookieName, state, {\n      sameSite: false,\n      httpOnly: true,\n    })\n\n    return state\n  }\n\n  /**\n   * Perform stateless authentication. Only applicable for Oauth2 client\n   */\n  stateless(): this {\n    this.isStateless = true\n    return this\n  }\n\n  /**\n   * Returns the redirect URL for the request.\n   */\n  async redirectUrl(\n    callback?: (request: RedirectRequestContract<Scopes>) => void\n  ): Promise<string> {\n    const url = this.getRedirectUrl(callback as any)\n    return url\n  }\n\n  /**\n   * Redirect user for authorization.\n   */\n  async redirect(callback?: (request: RedirectRequestContract<Scopes>) => void): Promise<void> {\n    const url = await this.redirectUrl((request) => {\n      const state = this.#persistState()\n      state && request.param(this.stateParamName, state)\n\n      if (typeof callback === 'function') {\n        callback(request)\n      }\n    })\n\n    this.ctx.response.redirect(url)\n  }\n\n  /**\n   * Find if there is a state mismatch\n   */\n  stateMisMatch(): boolean {\n    if (this.isStateless) {\n      return false\n    }\n\n    return this.stateCookieValue !== this.ctx.request.input(this.stateParamName)\n  }\n\n  /**\n   * Find if there is an error post redirect\n   */\n  hasError(): boolean {\n    return !!this.getError()\n  }\n\n  /**\n   * Get the post redirect error\n   */\n  getError(): string | null {\n    const error = this.ctx.request.input(this.errorParamName)\n    if (error) {\n      return error\n    }\n\n    if (!this.hasCode()) {\n      return 'unknown_error'\n    }\n\n    return null\n  }\n\n  /**\n   * Returns the authorization code\n   */\n  getCode(): string | null {\n    return this.ctx.request.input(this.codeParamName, null)\n  }\n\n  /**\n   * Find it the code exists\n   */\n  hasCode(): boolean {\n    return !!this.getCode()\n  }\n\n  /**\n   * Get access token\n   */\n  async accessToken(callback?: (request: ApiRequestContract) => void): Promise<Token> {\n    /**\n     * We expect the user to handle errors before calling this method\n     */\n    if (this.hasError()) {\n      throw new errors.E_OAUTH_MISSING_CODE([this.codeParamName])\n    }\n\n    /**\n     * We expect the user to properly handle the state mis-match use case before\n     * calling this method\n     */\n    if (this.stateMisMatch()) {\n      throw new errors.E_OAUTH_STATE_MISMATCH()\n    }\n\n    /**\n     * Get access token by providing the authorization code\n     */\n    return this.getAccessToken((request) => {\n      request.field(this.codeParamName, this.getCode())\n\n      if (typeof callback === 'function') {\n        callback(request)\n      }\n    })\n  }\n\n  /**\n   * Not applicable with Oauth2\n   */\n  async userFromTokenAndSecret(): Promise<never> {\n    throw new Exception(\n      '\"userFromTokenAndSecret\" is not applicable with Oauth2. Use \"userFromToken\" instead'\n    )\n  }\n}\n"],"mappings":"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","names":[]}